<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>PySense.PySenseDashboard API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PySense.PySenseDashboard</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import requests

from PySense import PySenseUtils
from PySense import PySenseWidget


class Dashboard:

    def __init__(self, host, token, dashboard_json):
        self._host = host
        self._token = token
        self._dashboard_json = dashboard_json

    def _reset(self, dashboard_json):
        self._dashboard_json = dashboard_json

    def get_dashboard_id(self):
        &#34;&#34;&#34;
        Gets the dashboard&#39;s id
        :return: The dashboard&#39;s id
        &#34;&#34;&#34;
        return self._dashboard_json[&#39;oid&#39;]

    def get_dashboard_title(self):
        &#34;&#34;&#34;
        Gets the dashboard&#39;s title
        :return: The dashboards title
        &#34;&#34;&#34;
        return self._dashboard_json[&#39;title&#39;]

    def get_dashboard_folder_id(self):
        &#34;&#34;&#34;
        Gets the dashboards folder id
        :return: The folder id of the parent folder of the dashboard
        &#34;&#34;&#34;
        return self._dashboard_json[&#39;parentFolder&#39;]

    def get_dashboard_shares(self):
        &#34;&#34;&#34;
        Gets the dashboard shares json

        :return: The dashboard shares json
        &#34;&#34;&#34;

        resp = requests.get(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_dashboard_id()),
            headers=self._token)
        PySenseUtils.parse_response(resp)
        return resp.json()

    def move_to_folder(self, folder):
        &#34;&#34;&#34;
        Move dashboard to given folder
        :param folder: Folder object to move dashboard to, None to remove from folder
        :return: True if successful
        &#34;&#34;&#34;
        if folder:
            folder_oid = folder.get_folder_id()
        else:
            folder_oid = None
        resp = requests.patch(
            &#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_dashboard_id()),
            headers=self._token, json={&#39;parentFolder&#39;: folder_oid})
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())
        return True

    def share_dashboard_to_user(self, email, rule, subscribe):
        &#34;&#34;&#34;
        Share a dashboard to a user
        :param email: The email address of the user
        :param rule: The permission of the user on the dashboard (view, edit, etc)
        :param subscribe: true or false, whether to subscribe the user to reports
        :return: The updated share
        &#34;&#34;&#34;

        user_id = PySenseUtils.get_user_id(self._host, self._token, email)
        shares = self.get_dashboard_shares()
        shares[&#39;sharesTo&#39;].append({&#39;shareId&#39;: user_id, &#39;type&#39;: &#39;user&#39;, &#39;rule&#39;: rule, &#39;subscribe&#39;: subscribe})
        resp = requests.post(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_dashboard_id()),
            headers=self._token, json=shares)
        PySenseUtils.parse_response(resp)
        return self.get_dashboard_shares()

    def unshare_dashboard_to_user(self, email):
        &#34;&#34;&#34;
        Unshare a dashboard to a user
        :param email: The email address of the user
        :return: The updated share
        &#34;&#34;&#34;

        shares = self.get_dashboard_shares()
        for i, share in enumerate(shares[&#39;sharesTo&#39;]):
            if share[&#39;email&#39;] == email:
                del shares[&#39;sharesTo&#39;][i]
        resp = requests.post(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_dashboard_id()),
            headers=self._token, json=shares)
        PySenseUtils.parse_response(resp)
        return self.get_dashboard_shares()

    def get_dashboard_export_png(self, path, *, include_title=None, include_filters=None, include_ds=None, width=None):
        &#34;&#34;&#34;
         Get dashboard as png

         :param path: Path to save location of png
         :param include_title: Should dashboard title be included in the exported file
         :param include_filters: Should dashboard filters be included in the exported file
         :param include_ds: Should dashboard data source info be included in the exported file
         :param width: Render width in pixels
         :return: The path of the created file
         &#34;&#34;&#34;
        param_string = PySenseUtils.build_query_string({
            &#39;includeTitle&#39;: include_title,
            &#39;includeFilters&#39;: include_filters,
            &#39;includeDs&#39;: include_ds,
            &#39;width&#39;: width
        })
        resp = requests.get(
            &#39;{}/api/v1/dashboards/{}/export/png?{}&#39;.format(self._host, self.get_dashboard_id(), param_string),
            headers=self._token)
        PySenseUtils.parse_response(resp)
        with open(path, &#39;wb&#39;) as out_file:
            out_file.write(resp.content)
        return path

    def get_dashboard_export_pdf(self, path, paper_format, paper_orientation, layout, *,
                                 include_title=None, include_filters=None, include_ds=None, widget_id=None, preview=None,
                                 row_count=None, show_title=None, show_footer=None, title=None, title_size=None,
                                 title_position=None):
        &#34;&#34;&#34;
        Get dashboard as pdf

        :param path: Path to save location of pdf
        :param paper_format: What paper format should be used while rendering the dashboard.
        :param paper_orientation: What paper orientation should be used while rendering the dashboard
        :param layout: What layout should be used while rendering the dashboard, as is or feed
        :param include_title: Should dashboard title be included in the exported file
        :param include_filters: Should dashboard filters be included in the exported file
        :param include_ds: Should dashboard datasource info be included in the exported file
        :param widget_id: Widget Id (Use only for Table and Pivot Widgets)
        :param preview: Should use a new Pixel Perfect Reporting
        :param row_count: Count of Table/Pivot rows to export
        :param show_title: Should Table/Pivot Widget title be included in the exported file
        :param show_footer: Should Table/Pivot Widget footer be included in the exported file
        :param title: Table/Pivot Widget title text in the exported file
        :param title_size: Table/Pivot widget title size in the exported file
        :param title_position: Table/Pivot widget title position in the exported file
        :return: The path of the created file
        &#34;&#34;&#34;
        param_string = PySenseUtils.build_query_string({
            &#39;paperFormat&#39;: paper_format,
            &#39;paperOrientation&#39;: paper_orientation,
            &#39;layout&#39;: layout,
            &#39;includeTitle&#39;: include_title,
            &#39;includeFilters&#39;: include_filters,
            &#39;includeDs&#39;: include_ds,
            &#39;widgetid&#39;: widget_id,
            &#39;preview&#39;: preview,
            &#39;rowCount&#39;: row_count,
            &#39;showTitle&#39;: show_title,
            &#39;showFooter&#39;: show_footer,
            &#39;title&#39;: title,
            &#39;titleSize&#39;: title_size,
            &#39;titlePosition&#39;: title_position
        })
        resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/pdf?{}&#39;
                            .format(self._host, self.get_dashboard_id(), param_string), headers=self._token)
        PySenseUtils.parse_response(resp)
        with open(path, &#39;wb&#39;) as out_file:
            out_file.write(resp.content)
        return path

    def get_dashboard_export_dash(self, path):
        &#34;&#34;&#34;
        Get dashboard as dash file

        :param path: Path to save location of dash file
        :return: The path of the created file
        &#34;&#34;&#34;
        resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/dash&#39;.format(self._host, self.get_dashboard_id()),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        with open(path, &#39;wb&#39;) as out_file:
            out_file.write(resp.content)
        return path

    def get_dashboard_widgets(self, *, title=None, type=None, subtype=None,
                              fields=None, sort=None, skip=None, limit=None):
        &#34;&#34;&#34;
        Returns an array of a dashboard’s widgets.

        @param title: Widget title to filter by
        @param type: Widget type to filter by
        @param subtype: Widget sub-type to filter by
        @param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
            by prefixing field names with -
        @param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -
        @param skip: Number of results to skip from the start of the data set. skip is to be used with the limit
            parameter for paging
        @param limit: How many results should be returned. limit is to be used with the skip parameter for paging
        @return: An array of widget objects
        &#34;&#34;&#34;
        param_string = PySenseUtils.build_query_string({
            &#39;title&#39;: title,
            &#39;type&#39;: type,
            &#39;subtype&#39;: subtype,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit
        })

        resp = requests.get(
            &#39;{}/api/v1/dashboards/{}/widgets?{}&#39;.format(self._host, self.get_dashboard_id(), param_string),
            headers=self._token)

        PySenseUtils.parse_response(resp)
        ret_arr = []
        widgets_json = json.loads(resp.content)
        for widget in widgets_json:
            ret_arr.append(PySenseWidget.Widget(self._host, self._token, widget))
        return ret_arr

    def get_dashboards_widget_by_id(self, widget_id, *, fields=None):
        &#34;&#34;&#34;
        Returns a specific widget (by ID) from a specific dashboard.

        @param widget_id: The ID of the widget to get
        @param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
            by prefixing field names with -
        @return: A widget object
        &#34;&#34;&#34;
        param_string = PySenseUtils.build_query_string({
            &#39;fields&#39;: fields
        })

        resp = requests.get(&#39;{}/api/v1/dashboards/{}/widgets/{}?{}&#39;.format(self._host, self.get_dashboard_id(),
                                                                           widget_id, param_string),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))

    def post_dashboards_widgets(self, widget):
        &#34;&#34;&#34;
        Adds the provided widget object to the dashboard

        @param widget: widget object to add
        @return: The widget added to the dashboard
        &#34;&#34;&#34;
        resp = requests.post(&#39;{}/api/v1/dashboards/{}/widgets&#39;.format(self._host, self.get_dashboard_id()),
                             headers=self._token, json=widget.get_widget_json())
        PySenseUtils.parse_response(resp)
        return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))

    def delete_dashboards_widgets(self, widget_id):
        &#34;&#34;&#34;
        Deletes a widget with the provided ID from it’s dashboard.

        @param widget_id: The ID of the widget to delete
        @return: True
        &#34;&#34;&#34;
        resp = requests.delete(&#39;{}/api/v1/dashboards/{}/widgets/{}&#39;
                               .format(self._host, self.get_dashboard_id(), widget_id), headers=self._token)
        PySenseUtils.parse_response(resp)
        # Get the updated dashboard from source and refresh object
        resp = requests.get(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_dashboard_id()),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())
        return True

    def does_widget_exist(self, widget_id):
        &#34;&#34;&#34;
        Returns whether or not a widget with the given id is in the dashboard
        :param widget_id: The widget id to look for
        :return: True if found, false if not.
        &#34;&#34;&#34;
        try:
            self.get_dashboards_widget_by_id(widget_id)
        except PySenseUtils.RestError:
            return False
        else:
            return True

    def remove_ghost_widgets(self):
        &#34;&#34;&#34;
        Removes ghost widgets from dashboard

        :return: True
        &#34;&#34;&#34;
        patch_json = {&#34;layout&#34;: self._dashboard_json[&#39;layout&#39;]}
        modified = True
        while modified:
            modified = False
            for l, column in enumerate(patch_json[&#39;layout&#39;][&#39;columns&#39;]):
                for k, cell in enumerate(column[&#39;cells&#39;]):
                    for j, sub_cell in enumerate(cell[&#39;subcells&#39;]):
                        for i, element in enumerate(sub_cell[&#39;elements&#39;]):
                            if not self.does_widget_exist(element[&#39;widgetid&#39;]):
                                sub_cell[&#39;elements&#39;].pop(i)
                                modified = True
                        if len(sub_cell[&#39;elements&#39;]) == 0:
                            cell[&#39;subcells&#39;].pop(j)
                    if len(cell[&#39;subcells&#39;]) == 0:
                        column[&#39;cells&#39;].pop(k)
                if len(column[&#39;cells&#39;]) == 0:
                    patch_json[&#39;layout&#39;][&#39;columns&#39;].pop(l)
        resp = requests.patch(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_dashboard_id()),
                              headers=self._token, json=patch_json)
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PySense.PySenseDashboard.Dashboard"><code class="flex name class">
<span>class <span class="ident">Dashboard</span></span>
<span>(</span><span>host, token, dashboard_json)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dashboard:

    def __init__(self, host, token, dashboard_json):
        self._host = host
        self._token = token
        self._dashboard_json = dashboard_json

    def _reset(self, dashboard_json):
        self._dashboard_json = dashboard_json

    def get_dashboard_id(self):
        &#34;&#34;&#34;
        Gets the dashboard&#39;s id
        :return: The dashboard&#39;s id
        &#34;&#34;&#34;
        return self._dashboard_json[&#39;oid&#39;]

    def get_dashboard_title(self):
        &#34;&#34;&#34;
        Gets the dashboard&#39;s title
        :return: The dashboards title
        &#34;&#34;&#34;
        return self._dashboard_json[&#39;title&#39;]

    def get_dashboard_folder_id(self):
        &#34;&#34;&#34;
        Gets the dashboards folder id
        :return: The folder id of the parent folder of the dashboard
        &#34;&#34;&#34;
        return self._dashboard_json[&#39;parentFolder&#39;]

    def get_dashboard_shares(self):
        &#34;&#34;&#34;
        Gets the dashboard shares json

        :return: The dashboard shares json
        &#34;&#34;&#34;

        resp = requests.get(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_dashboard_id()),
            headers=self._token)
        PySenseUtils.parse_response(resp)
        return resp.json()

    def move_to_folder(self, folder):
        &#34;&#34;&#34;
        Move dashboard to given folder
        :param folder: Folder object to move dashboard to, None to remove from folder
        :return: True if successful
        &#34;&#34;&#34;
        if folder:
            folder_oid = folder.get_folder_id()
        else:
            folder_oid = None
        resp = requests.patch(
            &#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_dashboard_id()),
            headers=self._token, json={&#39;parentFolder&#39;: folder_oid})
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())
        return True

    def share_dashboard_to_user(self, email, rule, subscribe):
        &#34;&#34;&#34;
        Share a dashboard to a user
        :param email: The email address of the user
        :param rule: The permission of the user on the dashboard (view, edit, etc)
        :param subscribe: true or false, whether to subscribe the user to reports
        :return: The updated share
        &#34;&#34;&#34;

        user_id = PySenseUtils.get_user_id(self._host, self._token, email)
        shares = self.get_dashboard_shares()
        shares[&#39;sharesTo&#39;].append({&#39;shareId&#39;: user_id, &#39;type&#39;: &#39;user&#39;, &#39;rule&#39;: rule, &#39;subscribe&#39;: subscribe})
        resp = requests.post(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_dashboard_id()),
            headers=self._token, json=shares)
        PySenseUtils.parse_response(resp)
        return self.get_dashboard_shares()

    def unshare_dashboard_to_user(self, email):
        &#34;&#34;&#34;
        Unshare a dashboard to a user
        :param email: The email address of the user
        :return: The updated share
        &#34;&#34;&#34;

        shares = self.get_dashboard_shares()
        for i, share in enumerate(shares[&#39;sharesTo&#39;]):
            if share[&#39;email&#39;] == email:
                del shares[&#39;sharesTo&#39;][i]
        resp = requests.post(
            &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_dashboard_id()),
            headers=self._token, json=shares)
        PySenseUtils.parse_response(resp)
        return self.get_dashboard_shares()

    def get_dashboard_export_png(self, path, *, include_title=None, include_filters=None, include_ds=None, width=None):
        &#34;&#34;&#34;
         Get dashboard as png

         :param path: Path to save location of png
         :param include_title: Should dashboard title be included in the exported file
         :param include_filters: Should dashboard filters be included in the exported file
         :param include_ds: Should dashboard data source info be included in the exported file
         :param width: Render width in pixels
         :return: The path of the created file
         &#34;&#34;&#34;
        param_string = PySenseUtils.build_query_string({
            &#39;includeTitle&#39;: include_title,
            &#39;includeFilters&#39;: include_filters,
            &#39;includeDs&#39;: include_ds,
            &#39;width&#39;: width
        })
        resp = requests.get(
            &#39;{}/api/v1/dashboards/{}/export/png?{}&#39;.format(self._host, self.get_dashboard_id(), param_string),
            headers=self._token)
        PySenseUtils.parse_response(resp)
        with open(path, &#39;wb&#39;) as out_file:
            out_file.write(resp.content)
        return path

    def get_dashboard_export_pdf(self, path, paper_format, paper_orientation, layout, *,
                                 include_title=None, include_filters=None, include_ds=None, widget_id=None, preview=None,
                                 row_count=None, show_title=None, show_footer=None, title=None, title_size=None,
                                 title_position=None):
        &#34;&#34;&#34;
        Get dashboard as pdf

        :param path: Path to save location of pdf
        :param paper_format: What paper format should be used while rendering the dashboard.
        :param paper_orientation: What paper orientation should be used while rendering the dashboard
        :param layout: What layout should be used while rendering the dashboard, as is or feed
        :param include_title: Should dashboard title be included in the exported file
        :param include_filters: Should dashboard filters be included in the exported file
        :param include_ds: Should dashboard datasource info be included in the exported file
        :param widget_id: Widget Id (Use only for Table and Pivot Widgets)
        :param preview: Should use a new Pixel Perfect Reporting
        :param row_count: Count of Table/Pivot rows to export
        :param show_title: Should Table/Pivot Widget title be included in the exported file
        :param show_footer: Should Table/Pivot Widget footer be included in the exported file
        :param title: Table/Pivot Widget title text in the exported file
        :param title_size: Table/Pivot widget title size in the exported file
        :param title_position: Table/Pivot widget title position in the exported file
        :return: The path of the created file
        &#34;&#34;&#34;
        param_string = PySenseUtils.build_query_string({
            &#39;paperFormat&#39;: paper_format,
            &#39;paperOrientation&#39;: paper_orientation,
            &#39;layout&#39;: layout,
            &#39;includeTitle&#39;: include_title,
            &#39;includeFilters&#39;: include_filters,
            &#39;includeDs&#39;: include_ds,
            &#39;widgetid&#39;: widget_id,
            &#39;preview&#39;: preview,
            &#39;rowCount&#39;: row_count,
            &#39;showTitle&#39;: show_title,
            &#39;showFooter&#39;: show_footer,
            &#39;title&#39;: title,
            &#39;titleSize&#39;: title_size,
            &#39;titlePosition&#39;: title_position
        })
        resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/pdf?{}&#39;
                            .format(self._host, self.get_dashboard_id(), param_string), headers=self._token)
        PySenseUtils.parse_response(resp)
        with open(path, &#39;wb&#39;) as out_file:
            out_file.write(resp.content)
        return path

    def get_dashboard_export_dash(self, path):
        &#34;&#34;&#34;
        Get dashboard as dash file

        :param path: Path to save location of dash file
        :return: The path of the created file
        &#34;&#34;&#34;
        resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/dash&#39;.format(self._host, self.get_dashboard_id()),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        with open(path, &#39;wb&#39;) as out_file:
            out_file.write(resp.content)
        return path

    def get_dashboard_widgets(self, *, title=None, type=None, subtype=None,
                              fields=None, sort=None, skip=None, limit=None):
        &#34;&#34;&#34;
        Returns an array of a dashboard’s widgets.

        @param title: Widget title to filter by
        @param type: Widget type to filter by
        @param subtype: Widget sub-type to filter by
        @param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
            by prefixing field names with -
        @param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -
        @param skip: Number of results to skip from the start of the data set. skip is to be used with the limit
            parameter for paging
        @param limit: How many results should be returned. limit is to be used with the skip parameter for paging
        @return: An array of widget objects
        &#34;&#34;&#34;
        param_string = PySenseUtils.build_query_string({
            &#39;title&#39;: title,
            &#39;type&#39;: type,
            &#39;subtype&#39;: subtype,
            &#39;fields&#39;: fields,
            &#39;sort&#39;: sort,
            &#39;skip&#39;: skip,
            &#39;limit&#39;: limit
        })

        resp = requests.get(
            &#39;{}/api/v1/dashboards/{}/widgets?{}&#39;.format(self._host, self.get_dashboard_id(), param_string),
            headers=self._token)

        PySenseUtils.parse_response(resp)
        ret_arr = []
        widgets_json = json.loads(resp.content)
        for widget in widgets_json:
            ret_arr.append(PySenseWidget.Widget(self._host, self._token, widget))
        return ret_arr

    def get_dashboards_widget_by_id(self, widget_id, *, fields=None):
        &#34;&#34;&#34;
        Returns a specific widget (by ID) from a specific dashboard.

        @param widget_id: The ID of the widget to get
        @param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
            by prefixing field names with -
        @return: A widget object
        &#34;&#34;&#34;
        param_string = PySenseUtils.build_query_string({
            &#39;fields&#39;: fields
        })

        resp = requests.get(&#39;{}/api/v1/dashboards/{}/widgets/{}?{}&#39;.format(self._host, self.get_dashboard_id(),
                                                                           widget_id, param_string),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))

    def post_dashboards_widgets(self, widget):
        &#34;&#34;&#34;
        Adds the provided widget object to the dashboard

        @param widget: widget object to add
        @return: The widget added to the dashboard
        &#34;&#34;&#34;
        resp = requests.post(&#39;{}/api/v1/dashboards/{}/widgets&#39;.format(self._host, self.get_dashboard_id()),
                             headers=self._token, json=widget.get_widget_json())
        PySenseUtils.parse_response(resp)
        return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))

    def delete_dashboards_widgets(self, widget_id):
        &#34;&#34;&#34;
        Deletes a widget with the provided ID from it’s dashboard.

        @param widget_id: The ID of the widget to delete
        @return: True
        &#34;&#34;&#34;
        resp = requests.delete(&#39;{}/api/v1/dashboards/{}/widgets/{}&#39;
                               .format(self._host, self.get_dashboard_id(), widget_id), headers=self._token)
        PySenseUtils.parse_response(resp)
        # Get the updated dashboard from source and refresh object
        resp = requests.get(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_dashboard_id()),
                            headers=self._token)
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())
        return True

    def does_widget_exist(self, widget_id):
        &#34;&#34;&#34;
        Returns whether or not a widget with the given id is in the dashboard
        :param widget_id: The widget id to look for
        :return: True if found, false if not.
        &#34;&#34;&#34;
        try:
            self.get_dashboards_widget_by_id(widget_id)
        except PySenseUtils.RestError:
            return False
        else:
            return True

    def remove_ghost_widgets(self):
        &#34;&#34;&#34;
        Removes ghost widgets from dashboard

        :return: True
        &#34;&#34;&#34;
        patch_json = {&#34;layout&#34;: self._dashboard_json[&#39;layout&#39;]}
        modified = True
        while modified:
            modified = False
            for l, column in enumerate(patch_json[&#39;layout&#39;][&#39;columns&#39;]):
                for k, cell in enumerate(column[&#39;cells&#39;]):
                    for j, sub_cell in enumerate(cell[&#39;subcells&#39;]):
                        for i, element in enumerate(sub_cell[&#39;elements&#39;]):
                            if not self.does_widget_exist(element[&#39;widgetid&#39;]):
                                sub_cell[&#39;elements&#39;].pop(i)
                                modified = True
                        if len(sub_cell[&#39;elements&#39;]) == 0:
                            cell[&#39;subcells&#39;].pop(j)
                    if len(cell[&#39;subcells&#39;]) == 0:
                        column[&#39;cells&#39;].pop(k)
                if len(column[&#39;cells&#39;]) == 0:
                    patch_json[&#39;layout&#39;][&#39;columns&#39;].pop(l)
        resp = requests.patch(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_dashboard_id()),
                              headers=self._token, json=patch_json)
        PySenseUtils.parse_response(resp)
        self._reset(resp.json())
        return True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PySense.PySenseDashboard.Dashboard.delete_dashboards_widgets"><code class="name flex">
<span>def <span class="ident">delete_dashboards_widgets</span></span>(<span>self, widget_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Deletes a widget with the provided ID from it’s dashboard.</p>
<p>@param widget_id: The ID of the widget to delete
@return: True</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_dashboards_widgets(self, widget_id):
    &#34;&#34;&#34;
    Deletes a widget with the provided ID from it’s dashboard.

    @param widget_id: The ID of the widget to delete
    @return: True
    &#34;&#34;&#34;
    resp = requests.delete(&#39;{}/api/v1/dashboards/{}/widgets/{}&#39;
                           .format(self._host, self.get_dashboard_id(), widget_id), headers=self._token)
    PySenseUtils.parse_response(resp)
    # Get the updated dashboard from source and refresh object
    resp = requests.get(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_dashboard_id()),
                        headers=self._token)
    PySenseUtils.parse_response(resp)
    self._reset(resp.json())
    return True</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.does_widget_exist"><code class="name flex">
<span>def <span class="ident">does_widget_exist</span></span>(<span>self, widget_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns whether or not a widget with the given id is in the dashboard
:param widget_id: The widget id to look for
:return: True if found, false if not.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def does_widget_exist(self, widget_id):
    &#34;&#34;&#34;
    Returns whether or not a widget with the given id is in the dashboard
    :param widget_id: The widget id to look for
    :return: True if found, false if not.
    &#34;&#34;&#34;
    try:
        self.get_dashboards_widget_by_id(widget_id)
    except PySenseUtils.RestError:
        return False
    else:
        return True</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_dashboard_export_dash"><code class="name flex">
<span>def <span class="ident">get_dashboard_export_dash</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"><p>Get dashboard as dash file</p>
<p>:param path: Path to save location of dash file
:return: The path of the created file</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboard_export_dash(self, path):
    &#34;&#34;&#34;
    Get dashboard as dash file

    :param path: Path to save location of dash file
    :return: The path of the created file
    &#34;&#34;&#34;
    resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/dash&#39;.format(self._host, self.get_dashboard_id()),
                        headers=self._token)
    PySenseUtils.parse_response(resp)
    with open(path, &#39;wb&#39;) as out_file:
        out_file.write(resp.content)
    return path</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_dashboard_export_pdf"><code class="name flex">
<span>def <span class="ident">get_dashboard_export_pdf</span></span>(<span>self, path, paper_format, paper_orientation, layout, *, include_title=None, include_filters=None, include_ds=None, widget_id=None, preview=None, row_count=None, show_title=None, show_footer=None, title=None, title_size=None, title_position=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get dashboard as pdf</p>
<p>:param path: Path to save location of pdf
:param paper_format: What paper format should be used while rendering the dashboard.
:param paper_orientation: What paper orientation should be used while rendering the dashboard
:param layout: What layout should be used while rendering the dashboard, as is or feed
:param include_title: Should dashboard title be included in the exported file
:param include_filters: Should dashboard filters be included in the exported file
:param include_ds: Should dashboard datasource info be included in the exported file
:param widget_id: Widget Id (Use only for Table and Pivot Widgets)
:param preview: Should use a new Pixel Perfect Reporting
:param row_count: Count of Table/Pivot rows to export
:param show_title: Should Table/Pivot Widget title be included in the exported file
:param show_footer: Should Table/Pivot Widget footer be included in the exported file
:param title: Table/Pivot Widget title text in the exported file
:param title_size: Table/Pivot widget title size in the exported file
:param title_position: Table/Pivot widget title position in the exported file
:return: The path of the created file</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboard_export_pdf(self, path, paper_format, paper_orientation, layout, *,
                             include_title=None, include_filters=None, include_ds=None, widget_id=None, preview=None,
                             row_count=None, show_title=None, show_footer=None, title=None, title_size=None,
                             title_position=None):
    &#34;&#34;&#34;
    Get dashboard as pdf

    :param path: Path to save location of pdf
    :param paper_format: What paper format should be used while rendering the dashboard.
    :param paper_orientation: What paper orientation should be used while rendering the dashboard
    :param layout: What layout should be used while rendering the dashboard, as is or feed
    :param include_title: Should dashboard title be included in the exported file
    :param include_filters: Should dashboard filters be included in the exported file
    :param include_ds: Should dashboard datasource info be included in the exported file
    :param widget_id: Widget Id (Use only for Table and Pivot Widgets)
    :param preview: Should use a new Pixel Perfect Reporting
    :param row_count: Count of Table/Pivot rows to export
    :param show_title: Should Table/Pivot Widget title be included in the exported file
    :param show_footer: Should Table/Pivot Widget footer be included in the exported file
    :param title: Table/Pivot Widget title text in the exported file
    :param title_size: Table/Pivot widget title size in the exported file
    :param title_position: Table/Pivot widget title position in the exported file
    :return: The path of the created file
    &#34;&#34;&#34;
    param_string = PySenseUtils.build_query_string({
        &#39;paperFormat&#39;: paper_format,
        &#39;paperOrientation&#39;: paper_orientation,
        &#39;layout&#39;: layout,
        &#39;includeTitle&#39;: include_title,
        &#39;includeFilters&#39;: include_filters,
        &#39;includeDs&#39;: include_ds,
        &#39;widgetid&#39;: widget_id,
        &#39;preview&#39;: preview,
        &#39;rowCount&#39;: row_count,
        &#39;showTitle&#39;: show_title,
        &#39;showFooter&#39;: show_footer,
        &#39;title&#39;: title,
        &#39;titleSize&#39;: title_size,
        &#39;titlePosition&#39;: title_position
    })
    resp = requests.get(&#39;{}/api/v1/dashboards/{}/export/pdf?{}&#39;
                        .format(self._host, self.get_dashboard_id(), param_string), headers=self._token)
    PySenseUtils.parse_response(resp)
    with open(path, &#39;wb&#39;) as out_file:
        out_file.write(resp.content)
    return path</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_dashboard_export_png"><code class="name flex">
<span>def <span class="ident">get_dashboard_export_png</span></span>(<span>self, path, *, include_title=None, include_filters=None, include_ds=None, width=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Get dashboard as png</p>
<p>:param path: Path to save location of png
:param include_title: Should dashboard title be included in the exported file
:param include_filters: Should dashboard filters be included in the exported file
:param include_ds: Should dashboard data source info be included in the exported file
:param width: Render width in pixels
:return: The path of the created file</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboard_export_png(self, path, *, include_title=None, include_filters=None, include_ds=None, width=None):
    &#34;&#34;&#34;
     Get dashboard as png

     :param path: Path to save location of png
     :param include_title: Should dashboard title be included in the exported file
     :param include_filters: Should dashboard filters be included in the exported file
     :param include_ds: Should dashboard data source info be included in the exported file
     :param width: Render width in pixels
     :return: The path of the created file
     &#34;&#34;&#34;
    param_string = PySenseUtils.build_query_string({
        &#39;includeTitle&#39;: include_title,
        &#39;includeFilters&#39;: include_filters,
        &#39;includeDs&#39;: include_ds,
        &#39;width&#39;: width
    })
    resp = requests.get(
        &#39;{}/api/v1/dashboards/{}/export/png?{}&#39;.format(self._host, self.get_dashboard_id(), param_string),
        headers=self._token)
    PySenseUtils.parse_response(resp)
    with open(path, &#39;wb&#39;) as out_file:
        out_file.write(resp.content)
    return path</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_dashboard_folder_id"><code class="name flex">
<span>def <span class="ident">get_dashboard_folder_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the dashboards folder id
:return: The folder id of the parent folder of the dashboard</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboard_folder_id(self):
    &#34;&#34;&#34;
    Gets the dashboards folder id
    :return: The folder id of the parent folder of the dashboard
    &#34;&#34;&#34;
    return self._dashboard_json[&#39;parentFolder&#39;]</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_dashboard_id"><code class="name flex">
<span>def <span class="ident">get_dashboard_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the dashboard's id
:return: The dashboard's id</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboard_id(self):
    &#34;&#34;&#34;
    Gets the dashboard&#39;s id
    :return: The dashboard&#39;s id
    &#34;&#34;&#34;
    return self._dashboard_json[&#39;oid&#39;]</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_dashboard_shares"><code class="name flex">
<span>def <span class="ident">get_dashboard_shares</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the dashboard shares json</p>
<p>:return: The dashboard shares json</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboard_shares(self):
    &#34;&#34;&#34;
    Gets the dashboard shares json

    :return: The dashboard shares json
    &#34;&#34;&#34;

    resp = requests.get(
        &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_dashboard_id()),
        headers=self._token)
    PySenseUtils.parse_response(resp)
    return resp.json()</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_dashboard_title"><code class="name flex">
<span>def <span class="ident">get_dashboard_title</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Gets the dashboard's title
:return: The dashboards title</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboard_title(self):
    &#34;&#34;&#34;
    Gets the dashboard&#39;s title
    :return: The dashboards title
    &#34;&#34;&#34;
    return self._dashboard_json[&#39;title&#39;]</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_dashboard_widgets"><code class="name flex">
<span>def <span class="ident">get_dashboard_widgets</span></span>(<span>self, *, title=None, type=None, subtype=None, fields=None, sort=None, skip=None, limit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an array of a dashboard’s widgets.</p>
<p>@param title: Widget title to filter by
@param type: Widget type to filter by
@param subtype: Widget sub-type to filter by
@param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
by prefixing field names with -
@param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -
@param skip: Number of results to skip from the start of the data set. skip is to be used with the limit
parameter for paging
@param limit: How many results should be returned. limit is to be used with the skip parameter for paging
@return: An array of widget objects</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboard_widgets(self, *, title=None, type=None, subtype=None,
                          fields=None, sort=None, skip=None, limit=None):
    &#34;&#34;&#34;
    Returns an array of a dashboard’s widgets.

    @param title: Widget title to filter by
    @param type: Widget type to filter by
    @param subtype: Widget sub-type to filter by
    @param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
        by prefixing field names with -
    @param sort: Field by which the results should be sorted. Ascending by default, descending if prefixed by -
    @param skip: Number of results to skip from the start of the data set. skip is to be used with the limit
        parameter for paging
    @param limit: How many results should be returned. limit is to be used with the skip parameter for paging
    @return: An array of widget objects
    &#34;&#34;&#34;
    param_string = PySenseUtils.build_query_string({
        &#39;title&#39;: title,
        &#39;type&#39;: type,
        &#39;subtype&#39;: subtype,
        &#39;fields&#39;: fields,
        &#39;sort&#39;: sort,
        &#39;skip&#39;: skip,
        &#39;limit&#39;: limit
    })

    resp = requests.get(
        &#39;{}/api/v1/dashboards/{}/widgets?{}&#39;.format(self._host, self.get_dashboard_id(), param_string),
        headers=self._token)

    PySenseUtils.parse_response(resp)
    ret_arr = []
    widgets_json = json.loads(resp.content)
    for widget in widgets_json:
        ret_arr.append(PySenseWidget.Widget(self._host, self._token, widget))
    return ret_arr</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.get_dashboards_widget_by_id"><code class="name flex">
<span>def <span class="ident">get_dashboards_widget_by_id</span></span>(<span>self, widget_id, *, fields=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a specific widget (by ID) from a specific dashboard.</p>
<p>@param widget_id: The ID of the widget to get
@param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
by prefixing field names with -
@return: A widget object</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dashboards_widget_by_id(self, widget_id, *, fields=None):
    &#34;&#34;&#34;
    Returns a specific widget (by ID) from a specific dashboard.

    @param widget_id: The ID of the widget to get
    @param fields: Whitelist of fields to return for each document. fields Can also define which fields to exclude
        by prefixing field names with -
    @return: A widget object
    &#34;&#34;&#34;
    param_string = PySenseUtils.build_query_string({
        &#39;fields&#39;: fields
    })

    resp = requests.get(&#39;{}/api/v1/dashboards/{}/widgets/{}?{}&#39;.format(self._host, self.get_dashboard_id(),
                                                                       widget_id, param_string),
                        headers=self._token)
    PySenseUtils.parse_response(resp)
    return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.move_to_folder"><code class="name flex">
<span>def <span class="ident">move_to_folder</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<section class="desc"><p>Move dashboard to given folder
:param folder: Folder object to move dashboard to, None to remove from folder
:return: True if successful</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_to_folder(self, folder):
    &#34;&#34;&#34;
    Move dashboard to given folder
    :param folder: Folder object to move dashboard to, None to remove from folder
    :return: True if successful
    &#34;&#34;&#34;
    if folder:
        folder_oid = folder.get_folder_id()
    else:
        folder_oid = None
    resp = requests.patch(
        &#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_dashboard_id()),
        headers=self._token, json={&#39;parentFolder&#39;: folder_oid})
    PySenseUtils.parse_response(resp)
    self._reset(resp.json())
    return True</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.post_dashboards_widgets"><code class="name flex">
<span>def <span class="ident">post_dashboards_widgets</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds the provided widget object to the dashboard</p>
<p>@param widget: widget object to add
@return: The widget added to the dashboard</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_dashboards_widgets(self, widget):
    &#34;&#34;&#34;
    Adds the provided widget object to the dashboard

    @param widget: widget object to add
    @return: The widget added to the dashboard
    &#34;&#34;&#34;
    resp = requests.post(&#39;{}/api/v1/dashboards/{}/widgets&#39;.format(self._host, self.get_dashboard_id()),
                         headers=self._token, json=widget.get_widget_json())
    PySenseUtils.parse_response(resp)
    return PySenseWidget.Widget(self._host, self._token, json.loads(resp.content))</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.remove_ghost_widgets"><code class="name flex">
<span>def <span class="ident">remove_ghost_widgets</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes ghost widgets from dashboard</p>
<p>:return: True</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_ghost_widgets(self):
    &#34;&#34;&#34;
    Removes ghost widgets from dashboard

    :return: True
    &#34;&#34;&#34;
    patch_json = {&#34;layout&#34;: self._dashboard_json[&#39;layout&#39;]}
    modified = True
    while modified:
        modified = False
        for l, column in enumerate(patch_json[&#39;layout&#39;][&#39;columns&#39;]):
            for k, cell in enumerate(column[&#39;cells&#39;]):
                for j, sub_cell in enumerate(cell[&#39;subcells&#39;]):
                    for i, element in enumerate(sub_cell[&#39;elements&#39;]):
                        if not self.does_widget_exist(element[&#39;widgetid&#39;]):
                            sub_cell[&#39;elements&#39;].pop(i)
                            modified = True
                    if len(sub_cell[&#39;elements&#39;]) == 0:
                        cell[&#39;subcells&#39;].pop(j)
                if len(cell[&#39;subcells&#39;]) == 0:
                    column[&#39;cells&#39;].pop(k)
            if len(column[&#39;cells&#39;]) == 0:
                patch_json[&#39;layout&#39;][&#39;columns&#39;].pop(l)
    resp = requests.patch(&#39;{}/api/v1/dashboards/{}&#39;.format(self._host, self.get_dashboard_id()),
                          headers=self._token, json=patch_json)
    PySenseUtils.parse_response(resp)
    self._reset(resp.json())
    return True</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.share_dashboard_to_user"><code class="name flex">
<span>def <span class="ident">share_dashboard_to_user</span></span>(<span>self, email, rule, subscribe)</span>
</code></dt>
<dd>
<section class="desc"><p>Share a dashboard to a user
:param email: The email address of the user
:param rule: The permission of the user on the dashboard (view, edit, etc)
:param subscribe: true or false, whether to subscribe the user to reports
:return: The updated share</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def share_dashboard_to_user(self, email, rule, subscribe):
    &#34;&#34;&#34;
    Share a dashboard to a user
    :param email: The email address of the user
    :param rule: The permission of the user on the dashboard (view, edit, etc)
    :param subscribe: true or false, whether to subscribe the user to reports
    :return: The updated share
    &#34;&#34;&#34;

    user_id = PySenseUtils.get_user_id(self._host, self._token, email)
    shares = self.get_dashboard_shares()
    shares[&#39;sharesTo&#39;].append({&#39;shareId&#39;: user_id, &#39;type&#39;: &#39;user&#39;, &#39;rule&#39;: rule, &#39;subscribe&#39;: subscribe})
    resp = requests.post(
        &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_dashboard_id()),
        headers=self._token, json=shares)
    PySenseUtils.parse_response(resp)
    return self.get_dashboard_shares()</code></pre>
</details>
</dd>
<dt id="PySense.PySenseDashboard.Dashboard.unshare_dashboard_to_user"><code class="name flex">
<span>def <span class="ident">unshare_dashboard_to_user</span></span>(<span>self, email)</span>
</code></dt>
<dd>
<section class="desc"><p>Unshare a dashboard to a user
:param email: The email address of the user
:return: The updated share</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unshare_dashboard_to_user(self, email):
    &#34;&#34;&#34;
    Unshare a dashboard to a user
    :param email: The email address of the user
    :return: The updated share
    &#34;&#34;&#34;

    shares = self.get_dashboard_shares()
    for i, share in enumerate(shares[&#39;sharesTo&#39;]):
        if share[&#39;email&#39;] == email:
            del shares[&#39;sharesTo&#39;][i]
    resp = requests.post(
        &#39;{}/api/shares/dashboard/{}&#39;.format(self._host, self.get_dashboard_id()),
        headers=self._token, json=shares)
    PySenseUtils.parse_response(resp)
    return self.get_dashboard_shares()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PySense" href="index.html">PySense</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PySense.PySenseDashboard.Dashboard" href="#PySense.PySenseDashboard.Dashboard">Dashboard</a></code></h4>
<ul class="">
<li><code><a title="PySense.PySenseDashboard.Dashboard.delete_dashboards_widgets" href="#PySense.PySenseDashboard.Dashboard.delete_dashboards_widgets">delete_dashboards_widgets</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.does_widget_exist" href="#PySense.PySenseDashboard.Dashboard.does_widget_exist">does_widget_exist</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_dashboard_export_dash" href="#PySense.PySenseDashboard.Dashboard.get_dashboard_export_dash">get_dashboard_export_dash</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_dashboard_export_pdf" href="#PySense.PySenseDashboard.Dashboard.get_dashboard_export_pdf">get_dashboard_export_pdf</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_dashboard_export_png" href="#PySense.PySenseDashboard.Dashboard.get_dashboard_export_png">get_dashboard_export_png</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_dashboard_folder_id" href="#PySense.PySenseDashboard.Dashboard.get_dashboard_folder_id">get_dashboard_folder_id</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_dashboard_id" href="#PySense.PySenseDashboard.Dashboard.get_dashboard_id">get_dashboard_id</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_dashboard_shares" href="#PySense.PySenseDashboard.Dashboard.get_dashboard_shares">get_dashboard_shares</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_dashboard_title" href="#PySense.PySenseDashboard.Dashboard.get_dashboard_title">get_dashboard_title</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_dashboard_widgets" href="#PySense.PySenseDashboard.Dashboard.get_dashboard_widgets">get_dashboard_widgets</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.get_dashboards_widget_by_id" href="#PySense.PySenseDashboard.Dashboard.get_dashboards_widget_by_id">get_dashboards_widget_by_id</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.move_to_folder" href="#PySense.PySenseDashboard.Dashboard.move_to_folder">move_to_folder</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.post_dashboards_widgets" href="#PySense.PySenseDashboard.Dashboard.post_dashboards_widgets">post_dashboards_widgets</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.remove_ghost_widgets" href="#PySense.PySenseDashboard.Dashboard.remove_ghost_widgets">remove_ghost_widgets</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.share_dashboard_to_user" href="#PySense.PySenseDashboard.Dashboard.share_dashboard_to_user">share_dashboard_to_user</a></code></li>
<li><code><a title="PySense.PySenseDashboard.Dashboard.unshare_dashboard_to_user" href="#PySense.PySenseDashboard.Dashboard.unshare_dashboard_to_user">unshare_dashboard_to_user</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>